{
module Lexer
open System
open System.Text
open Microsoft.FSharp.Text.Lexing
open System.Globalization;;

type token=
|ERROR of string|T_EOF
|T_BYTE|T_ELSE|T_FALSE|T_IF|T_INT|T_PROC|T_REF|T_RETURN|T_WHILE|T_TRUE
|BYTE of byte|INT of int|STRING of string |ID of string
|LPAREN|RPAREN|LSBR|RSBR|LCBR|RCBR|COMMA|COLON|SEMICOLON|ASSIGN
|EQ|NE|LT|LE|GT|GE|PLUS|MINUS|ASTER|SLASH|MOD|NOT|AND|OR

let keywords =
    [ "byte", T_BYTE;
      "else" , T_ELSE;
      "false" , T_FALSE;
      "if" , T_IF;
      "int" , T_INT;
      "proc" , T_PROC;
      "reference" , T_REF;
      "return" , T_RETURN;
      "while" , T_WHILE;
      "true" , T_TRUE;
    ] |>Map.ofList
let escape_chars=
    [ "\\n" , byte '\n';
      "\\t" , byte '\t';
      "\\r" , byte '\r';
      "\\\\" ,byte '\\';
      "\\\'" ,byte '\'';
      "\\\"" ,byte '\"';
      "\\0" , byte '\x00';
    ] |>Map.ofList

let lexeme = LexBuffer<char>.LexemeString
}

let letter			= ['a'-'z' 'A'-'Z']
let digit			= ['0'-'9']
let hex				= ['0'-'9' 'a'-'f' 'A'-'F']
let whitespace		= [' ' '\t' ]+
let newline			= ('\n' | '\r' '\n')
let identifier		= letter(letter|digit|'_')*
let char			= ('\'' [^'\''] [^'\'']? [^'\'']? [^'\'']? '\'')|("\'\\\'\'")
let acceptable_chars= [^ '\"' '\n' '\\']
let number			= digit+
let str             = ([' '-'!' '#'-'&' '('-'~']|"\\n" | "\\t" | "\\r" | "\\0" | "\\\\" | "\\'" | "\\\"")*
let lcomment		= "--"[^'\n']* '\n'

rule token = parse
| whitespace	{ token lexbuf }
| newline		{ lexbuf.EndPos <- lexbuf.EndPos.NextLine; token lexbuf }
| number		{ INT (Int32.Parse (lexeme lexbuf)) }
| identifier	{ let x=lexeme lexbuf in
                  match keywords.TryFind (x:string) with
                  | Some(token) ->token
                  | None -> ID x }
| '('			{ LPAREN }
| ')'			{ RPAREN }
| '['			{ LSBR }
| ']'			{ RSBR }
| '{'			{ LCBR }
| '}'			{ RCBR }
| ','			{ COMMA }
| ':'			{ COLON }
| ';'			{ SEMICOLON }
| '='			{ ASSIGN }
| "=="			{ EQ }
| "!="			{ NE }
| '<'			{ LT }
| "<="			{ LE }
| '>'			{ GT }
| ">="			{ GE }
| '+'			{ PLUS }
| '-'			{ MINUS }
| '*'			{ ASTER }
| '/'			{ SLASH }
| '%'			{ MOD }
| '!'			{ NOT }
| '&'			{ AND }
| '|'			{ OR }
| lcomment		{ token lexbuf }
| "(*"			{ comment 1 lexbuf }
| char			{ let y=lexeme lexbuf in 
                  let x=y.Substring (1,y.Length-2) in
                  match x.Length with
                  | 1 -> BYTE (byte x.[0])
                  | 2 -> 
                      match escape_chars.TryFind (x:string) with 
                      | Some esc_char -> BYTE esc_char
                      | None -> ERROR (sprintf "unrecognized escape sequence starting at %A : %s " (lexbuf.StartPos.Line+1,lexbuf.StartPos.Column+1) y)
                  | 4 -> 
                      if x.[0]='\\' && x.[1]='x' && Char.IsDigit(x.[2]) && Char.IsDigit(x.[3]) then BYTE (Byte.Parse (x.Substring (2,2),NumberStyles.HexNumber))
                      else ERROR (sprintf "unrecognized char starting at %A : %s " (lexbuf.StartPos.Line+1,lexbuf.StartPos.Column+1) y)
                  | _ -> ERROR (sprintf "unrecognized char starting at %A : %s " (lexbuf.StartPos.Line+1,lexbuf.StartPos.Column+1) y) }
|'\"' str '\"'  { let s=lexeme lexbuf in STRING (s.Substring(1,s.Length-2)) }
| eof			{ T_EOF }
| _             { error (lexbuf.StartPos.Line+1,lexbuf.StartPos.Column+1) (lexeme lexbuf) lexbuf }
and comment nest = parse
| "*)"			{ if (nest>1) then comment (nest-1) lexbuf
                  else token lexbuf }
| "(*"			{ comment (nest+1) lexbuf }
| "\n"			{ lexbuf.EndPos <- lexbuf.EndPos.NextLine; comment nest lexbuf }
| eof			{ ERROR "Unterminated comment" }
| _			    { comment nest lexbuf }
and error pos s = parse
| whitespace|eof{ ERROR (sprintf "unrecognized input starting at %A : %s " pos s) }
| newline		{ lexbuf.EndPos <- lexbuf.EndPos.NextLine; ERROR (sprintf "unrecognized input starting at %A : %s " pos s) }
| _				{ error pos (s + (lexeme lexbuf)) lexbuf}


{
let main ()=
    let lexbuf=LexBuffer<char>.FromTextReader stdin
    let rec loop () =
        try
            let token = token lexbuf
            match token with
            | ERROR y     -> printfn "%s" y; loop ()
            | T_EOF       -> printfn "End of file on lexing stream"
            | _           -> printfn "token = %A , lexeme = %s" token (lexeme lexbuf); loop ()
        with ex -> 
            printfn "%s" ex.Message
    loop ()
}