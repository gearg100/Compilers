%{

open Types
open ParserTypes
open QuadSupport
open Symbol
open Error
open AuxFunctions
open Identifier
open Microsoft.FSharp.Text.Lexing
open Microsoft.FSharp.Text.Parsing


let parse_error_rich = None

initSymbolTable 256
List.iter bulkLoad LibraryFunctions
%}
// The start token becomes a parser function in the compiled code:
%start start

// These are the terminal tokens of the grammar along with the types of
// the data carried by each token:
%token <byte> BYTE
%token <int> INT
%token <string> STRING
%token <string> ID
%token T_BYTE T_ELSE T_FALSE T_IF T_INT T_PROC T_REF T_RETURN T_WHILE T_TRUE T_EOF
%token LPAREN RPAREN LSBR RSBR LCBR RCBR COMMA COLON SEMICOLON ASSIGN
%token EQ NE LT LE GT GE PLUS MINUS ASTER SLASH MOD NOT AND OR


// This is the type of the data produced by a successful reduction of the 'start'
// symbol:
%type < quadType list > start
%type < quadType list > func_def
%type < unit > fpar_list
%type < unit > fpar_def
%type < entry > func_head
%type < typ > data_type
%type < typ > type
%type < typ > r_type
%type < quadType list > local_def
%type < quadType list > var_def
%type < quadType list > stmt
%type < quadType list > stmt_list
%type < quadType list > compound_stmt
%type < expressionType > func_call
%type < (expressionType list)*(pass_mode list) > expr_list
%type < expressionType > expr
%type < expressionType > l_value
%type < conditionType > cond
%type < string > compop
%type < expressionType > ref_value

%left OR
%left AND
%nonassoc EQ NE GT GE LT LE
%left PLUS MINUS
%left ASTER SLASH MOD
%left NOT NEG POS

%%

//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
start: func_def { $1 }
//-----------------------------------------------------------------------------------------------------------------------------------------
      |error T_EOF { let p=FindPosition parseState in fatal "Unrecognized Parse Error at %A\n" p }
//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
func_def: func_head func_params compound_stmt { closeScope (); processFunctionDefinition parseState $1 [] $3 }
         |func_head func_params local_def_list compound_stmt { closeScope (); processFunctionDefinition parseState $1 $3 $4 }
         |func_head func_params error { 
let (ps,pe)=parseState.ResultRange
error "Syntax Error at %A - %A: Statements in Function declaration must be inside curly brackets\n" (ps.Line,ps.Column) (pe.Line,pe.Column)
closeScope ()
[]
}
//-----------------------------------------------------------------------------------------------------------------------------------------
         |func_head func_params local_def_list error {
let (ps,pe)=parseState.ResultRange
error "Syntax Error at %A - %A: Statements in Function body must be inside curly brackets\n" (ps.Line,ps.Column) (pe.Line,pe.Column)
closeScope ()
[]
}
//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
func_head: ID { 
let f = newFunction (id_make $1) true
Some (f) |> openScope
f
}
//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
func_params: LPAREN RPAREN COLON r_type { endFunctionHeader (getScopeFunction()) $4 }
//-----------------------------------------------------------------------------------------------------------------------------------------
            |LPAREN fpar_list RPAREN COLON r_type { endFunctionHeader (getScopeFunction()) $5 }
//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
fpar_list: fpar_def { () } 
//-----------------------------------------------------------------------------------------------------------------------------------------
          |fpar_list COMMA fpar_def { () }
//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
fpar_def: ID COLON data_type { newParameter (id_make $1) $3 PASS_BY_VALUE (getScopeFunction()) true |>ignore }
//-----------------------------------------------------------------------------------------------------------------------------------------
         |ID COLON T_REF type { newParameter (id_make $1) $4 PASS_BY_REFERENCE (getScopeFunction()) true |>ignore}
//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
data_type: T_INT { TYPE_int }
//-----------------------------------------------------------------------------------------------------------------------------------------
          |T_BYTE { TYPE_byte }
//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
type: data_type { $1 }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |data_type LSBR RSBR { TYPE_array ($1,-1) }
//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
r_type: data_type { $1 }
//-----------------------------------------------------------------------------------------------------------------------------------------
       |T_PROC { TYPE_proc }
//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
local_def: func_def { $1 }
//-----------------------------------------------------------------------------------------------------------------------------------------
          |var_def { $1 }
//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
local_def_list: local_def { $1 }
//-----------------------------------------------------------------------------------------------------------------------------------------
               |local_def_list local_def { $2@$1 }
//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
var_def: ID COLON data_type SEMICOLON { newVariable (id_make $1) $3 false |>ignore; [] }
//-----------------------------------------------------------------------------------------------------------------------------------------
        |ID COLON data_type LSBR INT RSBR SEMICOLON { newVariable (id_make $1) (TYPE_array ($3,$5)) true |>ignore; [] }
//-----------------------------------------------------------------------------------------------------------------------------------------
        |ID COLON data_type error SEMICOLON {
let p=FindPosition parseState
error "Syntax Error at %A: Invalid Variable Definition %s: ';' or [integer] expected\n" p $1 |>ignore; [] }
//-----------------------------------------------------------------------------------------------------------------------------------------
        |ID COLON error SEMICOLON  {
let p=FindPosition parseState
error "Syntax Error at %A: Invalid Variable Definition %s: Invalid datatype after ':'\n" p $1 |>ignore; [] }
//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
stmt: SEMICOLON { [] }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |local_def { syntaxError parseState "Syntax Error at %A - %A: Cannot have declarations among statements\n" []}
//-----------------------------------------------------------------------------------------------------------------------------------------
     |l_value ASSIGN expr SEMICOLON { processAssignment parseState $1 $3 }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |compound_stmt { $1 }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |func_call SEMICOLON { processFunctionCallStmt parseState $1 }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |T_IF LPAREN cond RPAREN stmt { processIfStmt parseState $3 $5 }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |T_IF LPAREN cond RPAREN stmt T_ELSE stmt { processIfElseStmt parseState $3 $5 $7 }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |T_WHILE LPAREN cond RPAREN stmt { processWhileStmt parseState $3 $5 }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |T_RETURN SEMICOLON { processReturnStmt parseState }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |T_RETURN expr SEMICOLON { processReturnExpressionStmt parseState $2 }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |l_value ASSIGN error SEMICOLON { syntaxError parseState "Syntax Error at %A - %A: Invalid Assignment - Expression expected\n" []}
//-----------------------------------------------------------------------------------------------------------------------------------------
     |l_value error SEMICOLON { syntaxError parseState "Syntax Error at %A - %A: Invalid Assignment - '=' expected\n" []}
//-----------------------------------------------------------------------------------------------------------------------------------------
     |T_IF error stmt { syntaxError parseState "Syntax Error at %A - %A: Condition in parentheses expected\n" []}
//-----------------------------------------------------------------------------------------------------------------------------------------
     |T_IF error stmt T_ELSE stmt { syntaxError parseState "Syntax Error at %A - %A: Condition in parentheses expected\n" []}
//-----------------------------------------------------------------------------------------------------------------------------------------
     |T_WHILE error stmt { syntaxError parseState "Syntax Error at %A - %A: Condition in parentheses expected\n" []}
//-----------------------------------------------------------------------------------------------------------------------------------------
     |T_RETURN error SEMICOLON { syntaxError parseState "Syntax Error at %A - %A: Invalid Return Statement\n" []}
//-----------------------------------------------------------------------------------------------------------------------------------------
     |error SEMICOLON { syntaxError parseState "Syntax Error at %A - %A: Invalid Statement\n" []}
//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
stmt_list: stmt { $1 }
//-----------------------------------------------------------------------------------------------------------------------------------------
          |stmt_list stmt { $2@$1 }
//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
compound_stmt: LCBR RCBR { [] }
//-----------------------------------------------------------------------------------------------------------------------------------------
              |LCBR stmt_list RCBR { $2 }
//-----------------------------------------------------------------------------------------------------------------------------------------
              |LCBR error RCBR { syntaxError parseState "Syntax Error at %A - %A: Invalid Function body\n" []}
//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
func_call: ID LPAREN RPAREN { processFunctionCall parseState $1 ([],[]) }
//-----------------------------------------------------------------------------------------------------------------------------------------
          |ID LPAREN expr_list RPAREN { processFunctionCall parseState $1 $3 }
//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
expr_list: expr   { ([$1],[PASS_BY_VALUE]) }
//-----------------------------------------------------------------------------------------------------------------------------------------
          |ref_value { ([$1],[PASS_BY_REFERENCE]) }
//-----------------------------------------------------------------------------------------------------------------------------------------
          |expr_list COMMA expr { (($3::(fst $1)),(PASS_BY_VALUE::(snd $1))) }
//-----------------------------------------------------------------------------------------------------------------------------------------
          |expr_list COMMA ref_value { (($3::(fst $1)),(PASS_BY_REFERENCE::(snd $1))) }
//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------

expr: INT { { Code = []; Place = Int($1) } }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |BYTE { { Code = []; Place = Byte($1) } }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |l_value { processLValueExpression parseState $1 }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |LPAREN expr RPAREN { $2 }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |func_call { processFunctionCallExpression parseState $1 }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |PLUS expr %prec POS { processExpression parseState (QuadAdd) $2 None }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |MINUS expr %prec NEG { processExpression parseState (QuadSub) $2 None }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |expr MINUS expr{ processExpression parseState (QuadSub) $1 (Some $3) }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |expr PLUS expr{ processExpression parseState (QuadAdd) $1 (Some $3) }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |expr ASTER expr{ processExpression parseState (QuadMult) $1 (Some $3) }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |expr SLASH expr{ processExpression parseState (QuadDiv) $1 (Some $3) }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |expr MOD expr{ processExpression parseState (QuadMod) $1 (Some $3) }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |error MINUS expr{ syntaxError parseState "Syntax Error at %A - %A: Invalid Expression\n" voidExpression }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |error PLUS expr{ syntaxError parseState "Syntax Error at %A - %A: Invalid Expression\n" voidExpression }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |error ASTER expr{ syntaxError parseState "Syntax Error at %A - %A: Invalid Expression\n" voidExpression }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |error SLASH expr{ syntaxError parseState "Syntax Error at %A - %A: Invalid Expression\n" voidExpression }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |error MOD expr{ syntaxError parseState "Syntax Error at %A - %A: Invalid Expression\n" voidExpression }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |expr MINUS error{ syntaxError parseState "Syntax Error at %A - %A: Invalid Expression\n" voidExpression }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |expr PLUS error{ syntaxError parseState "Syntax Error at %A - %A: Invalid Expression\n" voidExpression }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |expr ASTER error{ syntaxError parseState "Syntax Error at %A - %A: Invalid Expression\n" voidExpression }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |expr SLASH error{ syntaxError parseState "Syntax Error at %A - %A: Invalid Expression\n" voidExpression }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |expr MOD error{ syntaxError parseState "Syntax Error at %A - %A: Invalid Expression\n" voidExpression }
//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------

ref_value: |STRING { { Code = []; Place = String($1) } }
//-----------------------------------------------------------------------------------------------------------------------------------------
           |ID     { ProcessLValue1 parseState $1 }
//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
l_value: ID  { ProcessLValue2 parseState $1 }
//-----------------------------------------------------------------------------------------------------------------------------------------
        |ID LSBR expr RSBR { ProcessLValue3 parseState $1 $3 }
//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
cond: T_TRUE { processTrue () }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |T_FALSE { processFalse () }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |LPAREN cond RPAREN { $2 }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |NOT cond { { Code=$2.Code ; True=$2.False ; False=$2.True } }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |expr compop expr { processComparison parseState (functionize $2) $1 $3 }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |cond AND cond { processAndCondition parseState $1 $3 }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |cond OR cond { processOrCondition parseState $1 $3 }
//-----------------------------------------------------------------------------------------------------------------------------------------
     |expr compop error { syntaxError parseState "Syntax Error at %A: Invalid Condition\n" voidCondition}
//-----------------------------------------------------------------------------------------------------------------------------------------
     |error compop expr { syntaxError parseState "Syntax Error at %A: Invalid Condition\n" voidCondition}
//-----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
compop: EQ { "EQ" }
//-----------------------------------------------------------------------------------------------------------------------------------------
       |NE { "NE" }
//-----------------------------------------------------------------------------------------------------------------------------------------
       |LT { "LT" }
//-----------------------------------------------------------------------------------------------------------------------------------------
       |GT { "GT" }
//-----------------------------------------------------------------------------------------------------------------------------------------
       |LE { "LE" }
//-----------------------------------------------------------------------------------------------------------------------------------------
       |GE { "GE" }
//-----------------------------------------------------------------------------------------------------------------------------------------