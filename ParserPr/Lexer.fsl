{
module Lexer
open Parser
open System
open System.Text
open Microsoft.FSharp.Text.Lexing
open System.Globalization;;

let keywords =
    [ "byte", T_BYTE;
      "else" , T_ELSE;
      "false" , T_FALSE;
      "if" , T_IF;
      "int" , T_INT;
      "proc" , T_PROC;
      "reference" , T_REF;
      "return" , T_RETURN;
      "while" , T_WHILE;
      "true" , T_TRUE;
    ] |>Map.ofList
let escape_chars=
    [ "\\n" , '\n';
      "\\t" , '\t';
      "\\r" , '\r';
      "\\\\" , '\\';
      "\\\'" , '\'';
      "\\\"" , '\"';
      "\\0" , '\x00';
    ] |>Map.ofList

let lexeme = LexBuffer<char>.LexemeString
}

let letter			= ['a'-'z' 'A'-'Z']
let digit			= ['0'-'9']
let hex				= ['0'-'9' 'a'-'f' 'A'-'F']
let whitespace		= [' ' '\t' ]+
let newline			= ('\n' | '\r' '\n')
let identifier		= letter(letter|digit|'_')*
let char			= ('\'' [^'\''] [^'\'']? [^'\'']? [^'\'']? '\'')|("\'\\\'\'")
let acceptable_chars= [^ '\"' '\n' '\\']
let number			= digit+
let lcomment		= "--"[^'\n']* '\n'

rule token = parse
| whitespace	{ token lexbuf }
| newline		{ lexbuf.EndPos <- lexbuf.EndPos.NextLine; token lexbuf }
| number		{ INT (Int32.Parse (lexeme lexbuf)) }
| identifier	{ let x=lexeme lexbuf in
                  match keywords.TryFind (x:string) with
                  | Some(token) ->token
                  | None -> ID x }
| '('			{ LPAREN }
| ')'			{ RPAREN }
| '['			{ LSBR }
| ']'			{ RSBR }
| '{'			{ LCBR }
| '}'			{ RCBR }
| ','			{ COMMA }
| ':'			{ COLON }
| ';'			{ SEMICOLON }
| '='			{ ASSIGN }
| "=="			{ EQ }
| "!="			{ NE }
| '<'			{ LT }
| "<="			{ LE }
| '>'			{ GT }
| ">="			{ GE }
| '+'			{ PLUS }
| '-'			{ MINUS }
| '*'			{ ASTER }
| '/'			{ SLASH }
| '%'			{ MOD }
| '!'			{ NOT }
| '&'			{ AND }
| '|'			{ OR }
| lcomment		{ token lexbuf }
| "(*"			{ comment 1 lexbuf }
| char			{ let y=lexeme lexbuf in 
                  let x=y.Substring (1,y.Length-2) in
                  match x.Length with
                  | 1 -> BYTE (Char.Parse x)
                  | 2 -> 
                      match escape_chars.TryFind (x:string) with 
                      | Some esc_char -> BYTE esc_char
                      | None -> ERROR (sprintf "unrecognized escape sequence starting at %A : %s " (lexbuf.StartPos.Line+1,lexbuf.StartPos.Column+1) y)
                  | 4 -> 
                      if x.[0]='\\' && x.[1]='x' && Char.IsDigit(x.[2]) && Char.IsDigit(x.[3]) then BYTE (Convert.ToChar (Int32.Parse (x.Substring (2,2),NumberStyles.HexNumber)))
                      else ERROR (sprintf "unrecognized char starting at %A : %s " (lexbuf.StartPos.Line+1,lexbuf.StartPos.Column+1) y)
                  | _ -> ERROR (sprintf "unrecognized char starting at %A : %s " (lexbuf.StartPos.Line+1,lexbuf.StartPos.Column+1) y) }
| '\"'			{ string (lexbuf.StartPos.Line+1,lexbuf.StartPos.Column+1) ("") ("\"") lexbuf }
| eof			{ T_EOF }
| _             { error (lexbuf.StartPos.Line+1,lexbuf.StartPos.Column+1) (lexeme lexbuf) lexbuf }
and comment nest = parse
| "*)"			{ if (nest>1) then comment (nest-1) lexbuf
                  else token lexbuf }
| "(*"			{ comment (nest+1) lexbuf }
| "\n"			{ lexbuf.EndPos <- lexbuf.EndPos.NextLine; comment nest lexbuf }
| eof			{ ERROR "Unterminated comment" }
| _			    { comment nest lexbuf }
and error pos s = parse
| whitespace|eof{ ERROR (sprintf "unrecognized input starting at %A : %s " pos s) }
| newline		{ lexbuf.EndPos <- lexbuf.EndPos.NextLine; ERROR (sprintf "unrecognized input starting at %A : %s " pos s) }
| _				{ error pos (s + (lexeme lexbuf)) lexbuf}
and string pos s lex = parse
| '\\' ('\"'|'n'|'r'|'t'|'\\')
                { let s' = s + (match lexeme lexbuf with
                                | "\\\"" -> "\""
                                | "\\n"  -> "\n"
                                | "\\r"  -> "\r"
                                | "\\t"  -> "\t"
                                | "\\\\" -> "\\"
                                | _      -> "" )
                  string pos s' (lex+(lexeme lexbuf)) lexbuf }
| '\\' 'x' hex hex	{ let x=lexeme lexbuf in string pos (s+((Convert.ToChar (Int32.Parse (x.Substring (2,2),NumberStyles.HexNumber))).ToString ())) (lex+(lexeme lexbuf)) lexbuf }
| '\"'				{ STRING (s,lex+"\"") }
| '\n'|('\r' '\n')	{ lexbuf.EndPos <- lexbuf.EndPos.NextLine; ERROR (sprintf "unfinished string starting at %A : %s " pos lex) }
| eof				{ ERROR (sprintf "unfinished string starting at %A : %s " pos lex) }
| (acceptable_chars)* { string pos (s+(lexeme lexbuf)) (lex+(lexeme lexbuf)) lexbuf }
